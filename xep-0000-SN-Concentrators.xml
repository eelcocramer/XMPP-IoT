<?xml version='1.0' encoding='UTF-8'?>
<!-- TODO: required data sources, optional data sources -->
<!-- TODO: enhanced concentrator GUI XEP. (Icons, overlays, etc.) -->
<!-- TODO: Interaction with provisioning server -->
<!-- TODO: Error message when command is not supported -->
<!DOCTYPE xep SYSTEM 'xep.dtd' [
    <!ENTITY % ents SYSTEM 'xep.ent'>
    %ents;
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
    <header>
        <title>XEP - Sensor Networks - Concentrators</title>
        <abstract>This specification describes how to manage and get information from concentrators of devices over XMPP networks.</abstract>
        <legal>
            <copyright>This XMPP Extension Protocol is copyright (c) 1999 - 2013 by the XMPP Standards Foundation (XSF).</copyright>
            <permissions>Permission is hereby granted, free of charge, to any person obtaining a copy of this specification (the &quot;Specification&quot;), to make use of the Specification without restriction, including without limitation the rights to implement the Specification in a software program, deploy the Specification in a network service, and copy, modify, merge, publish, translate, distribute, sublicense, or sell copies of the Specification, and to permit persons to whom the Specification is furnished to do so, subject to the condition that the foregoing copyright notice and this permission notice shall be included in all copies or substantial portions of the Specification. Unless separate permission is granted, modified works that are redistributed shall not contain misleading information regarding the authors, title, number, or publisher of the Specification, and shall not claim endorsement of the modified works by the authors, any organization or project to which the authors belong, or the XMPP Standards Foundation.</permissions>
            <warranty>## NOTE WELL: This Specification is provided on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. In no event shall the XMPP Standards Foundation or the authors of this Specification be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the Specification or the implementation, deployment, or other use of the Specification. ##</warranty>
            <liability>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall the XMPP Standards Foundation or any author of this Specification be liable for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising out of the use or inability to use the Specification (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if the XMPP Standards Foundation or such author has been advised of the possibility of such damages.</liability>
            <conformance>
                This XMPP Extension Protocol has been contributed in full conformance with the XSF's Intellectual Property Rights Policy (a copy of which may be found at &lt;<link url='http://www.xmpp.org/extensions/ipr-policy.shtml'>http://www.xmpp.org/extensions/ipr-policy.shtml</link>&gt; or obtained by writing to XSF, P.O. Box 1641, Denver, CO 80201 USA).
            </conformance>
        </legal>
        <number>xxxx</number>
        <status>ProtoXEP</status>
        <type>Standards Track</type>
        <sig>Standards</sig>
        <approver>Council</approver>
        <dependencies>
            <spec>XMPP Core</spec>
            <spec>XEP-0001</spec>
            <spec>XEP-0004</spec>
            <spec>XEP-0030</spec>
            <spec>XEP-0122</spec>
            <spec>XEP-0137</spec>
            <spec>XEP-0141</spec>
            <spec>xep-0000-SN-SensorData</spec>
            <spec>xep-0000-DynamicForms</spec>
        </dependencies>
        <supersedes/>
        <supersededby/>
        <shortname>NOT_YET_ASSIGNED</shortname>
        <author>
            <firstname>Peter</firstname>
            <surname>Waher</surname>
            <email>peter.waher@clayster.com</email>
            <jid>peter.waher@jabber.org</jid>
            <uri>http://se.linkedin.com/pub/peter-waher/1a/71b/a29/</uri>
        </author>
        <revision>
            <version>0.0.1</version>
            <date>2001-09-14</date>
            <initials>psa</initials>
            <remark>
                <p>First draft.</p>
            </remark>
        </revision>
    </header>
    <section1 topic='Introduction' anchor='intro'>
        <p>
            Concentrators are devices in sensor networks, concentrating the management of a sub set of devices to one point. They can be small (for example: PLC:s managing a small
            set of sensors and actuators), medium-sized (for example: mid-level concentrators, controlling branches of the network, islands, perhaps using separate comunication protocols),
            large (for example: entire sub-systems, perhaps managed by a separate child/partner organisation) to massive (for example: The entire top-level system, smart-grid, IoT network).
        </p>
        <p>
            Even though this XEP is generally written and can be used by other implementations not based on sensor networks, much of the requirements used to define this specification
            comes from requirements used in sensor networks and Internet of Things applications and infrastructure.
        </p>
        <p>
            This specification will define the following aspects of a general concentrator profile, that can handle all different types of concentrators available in sensor network architectures:
        </p>
        <ul>
            <li>
                A concentrator works with multiple <strong>data sources</strong>. Effective management of data sources and their contents is a vital part of this XEP.
            </li>
            <li>The ability to work with massive cuantities of entities.</li>
            <li>Effective synchronization of contents between interested parties.</li>
            <li>Effective ways to interact with entities controlled by the concentrator.</li>
        </ul>
        <p>
            Even though there are technologies available in forms of XEPs that solve parts of the above mentioned problem, they do not provide sufficient support. The following paragraphs will
            take the time to list why different tachnologies are not applicable.
        </p>
        <p>
            This XEP defines tree structures for nodes in different data sources. &xep0060; defines a model where a tree structure of nodes is published and users can browse this
            tree structure. Furthermore, it allows the possibility to publish items on these nodes as well as syndicalization of this information.
        </p>
        <p>
            This XEP also defines data sources (in a tree structure). These data sources contain nodes. &xep0248; defines a structure called a node collection, a structure that 
            allows the creation of collections containing loosly coupled nodes.
        </p>
        <p>
            Even though this document defines tree structures of data, it is not however based on XEP-0060. There are multiple reasons for this:
        </p>
        <ul>
            <li>
                The structures defined in this specification do not include items to publish for each node.
            </li>
            <li>
                We want to be able to use XEP-0060 in parallell to this specification, for the purpose of publishing sensor data.
                More information about this is found in <link url='xep-0000-SN-PubSub.html'>xep-0000-SN-PubSub.html</link>.
            </li>
            <li>
                For massive systems (hundreds of thousands, or millions, of nodes behind a concentrator, its vitally important to be able to manage sets of nodes directly 
                (for example: Edit multiple nodes at once). Many of the operations in XEP-0060 only allow for operations of singular nodes. Firthermore, many simple operations 
                require multiple messages per node. This document defines way to operate of sets of nodes simultaneously, as well as ways to perform operations with a smaller 
                number of operations.
            </li>
            <li>
                In this document, nodes have specific functions, controlled by a specific Node Type. Different Node Types have different parameter sets, different options, commands, 
                capabilities, etc. XEP-0060 does not differ between node types. There, nodes are only a structural way to sort data into a tree graph.
            </li>
            <li>
                In this document, nodes have real-time status, like errors, warnings, etc.
            </li>
        </ul>
        <p>
            XEP-0248 defines the concept of node collections and syndicalization of information from nodes in these collections. But XEP-0248 is not used in this specification.
            There are multiple reasons:
        </p>
        <ul>
            <li>
                We want to be able to use XEP-0248 in parallell to this specification, for the purpose of publishing sensor data.
                More information about this is found in <link url='xep-0000-SN-PubSub.html'>xep-0000-SN-PubSub.html</link>.
            </li>
            <li>
                Node IDs are not necessarily unique by themselves in the system. This document defines a uniqueness concept based on a triple of data: (Data Source ID, Cache Type, Node ID). This
                means that Nodes must have IDs unique within a given Cache Type, within a given data source.
            </li>
            <li>
                We need to expand on types of events generated from a data source, to make them adhere to the particulars of nodes as defined in this specification.
            </li>
            <li>
                Data sources own their nodes. XEP-0248 define a loosly coupled structure with references to nodes. In this document, a data source is the owner of all nodes
                contained in it.
            </li>
        </ul>
        <p>
            &xep0050; defines how ad-hoc commands can be implemented and how clients can use such commands to interact with underlying logic. But XEP-0050 is not used in this specification.
            There are multiple reasons:
        </p>
        <ul>
            <li>
                We want to be able to use XEP-0050 for other types of commands, than commands defined in this specification. Generally, XEP-0050 is used to implement
                system-wide commands.
            </li>
            <li>
                Commands defined in this specification are context sensitive, i.e. they depend on the type of node and the context of the node on which the act.
            </li>
            <li>
                It is a requirement to be able to execute commands on sets of nodes directly.
            </li>
            <li>
                Since commands have to be context sensitive, a large concentrator system may have hundreds or thousands of different commands, making it impossible to create
                context sensitive GUI's using XEP-0050.
            </li>
            <li>
                Dialog types used for Ad-Hoc-commands are not sufficient. First, dynamic dialogs are required in the general case. 
                (XEP <link url='xep-0000-DynamicForms.html'>xep-0000-DynamicForms.html</link> define how to create dynamic forms.) Further more, the
                wizard style type of dialogs used for more complex dialogs in ad-hoc commands, are difficult to automate.
            </li>
        </ul>

        <p>
            Sensor networks contains many different architectures and use cases. For this reason, the sensor network standards have been divided into multiple XEPs according to the following table:
        </p>

        <table caption='Sensor Network XEPs'>
            <tr>
                <th>XEP</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>XEP-0000-DynamicForms</td>
                <td>Defines extensions for how dynamic forms can be created, based on &xep0004;, &xep0122;, &xep0137; and &xep0141;.</td>
            </tr>
            <tr>
                <td>XEP-0000-Exi</td>
                <td>
                    Defines how to EXI can be used in XMPP to achieve efficient compression of data. Albeit not a sensor network specific XEP, this XEP should be considered
                    in all sensor network implementations where memory and packet size is an issue.
                </td>
            </tr>
            <tr>
                <td>xep-0000-SN-BatteryPoweredSensors</td>
                <td>Defines how to handle the peculiars related to battery powered devices, and other devices intermittently available on the network.</td>
            </tr>
            <tr>
                <td>xep-0000-SN-Concentrators</td>
                <td>This specification. Defines how to handle architectures containing concentrators or servers handling multiple sensors.</td>
            </tr>
            <tr>
                <td>xep-0000-SN-Control</td>
                <td>Defines how to control actuators and other devices in sensor networks.</td>
            </tr>
            <tr>
                <td>xep-0000-SN-Discovery</td>
                <td>Defines the peculiars of sensor discovery in sensor networks. Apart from discovering sensors by JID, it also defines how to discover sensors based on location, etc.</td>
            </tr>
            <tr>
                <td>xep-0000-SN-Events</td>
                <td>Defines how sensors send events, how event subscription, hysteresis levels, etc., are configured.</td>
            </tr>
            <tr>
                <td>xep-0000-SN-Interoperability</td>
                <td>Defines guidelines for how to achieve interoperability in sensor networks, publishing interoperability interfaces for different types of devices.</td>
            </tr>
            <tr>
                <td>xep-0000-SN-Multicast</td>
                <td>Defines how sensor data can be multicast in efficient ways.</td>
            </tr>
            <tr>
                <td>xep-0000-SN-Provisioning</td>
                <td>Defines how provisioning, the management of access privileges, etc., can be efficiently and easily implemented.</td>
            </tr>
            <tr>
                <td>xep-0000-SN-PubSub</td>
                <td>Defines how efficient publication of sensor data can be made in sensor networks.</td>
            </tr>
            <tr>
                <td>xep-0000-SN-SensorData</td>
                <td>
                    Provides the underlying architecture, basic operations and data structures for sensor data communication over XMPP networks.
                    It includes a hardware abstraction model, removing any technical detail implemented in underlying technologies. This XEP is used by all other sensor network XEPs.
                </td>
            </tr>
        </table>
    </section1>
    <section1 topic='Glossary' anchor='glossary'>
        <p>The following table lists common terms and corresponding descriptions.</p>
        <table caption='Glossary'>
            <tr>
                <th>Term</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>Actuator</td>
                <td>Device containing at least one configurable property or output that can and should be controlled by some other entity or device.</td>
            </tr>
            <tr>
                <td>Cache Type</td>
                <td>Node IDs are unique within a given cache type (and data source id). Examples of cache types may be: Sensor nodes, streets, buildings, groupings, etc.</td>
            </tr>
            <tr>
                <td>Computed Value</td>
                <td>A value that is computed instead of measured.</td>
            </tr>
            <tr>
                <td>Concentrator</td>
                <td>Device managing a set of devices which it publishes on the XMPP network.</td>
            </tr>
            <tr>
                <td>Data Source</td>
                <td>A Data source contains a collection of nodes. Three types of data sources exist: Singular, Flat and Tree. Singular data sources only include one object.
                Flat data sources contain a list of objects and Tree data sources contain nodes formed as a tree graph with one root element.</td>
            </tr>
            <tr>
                <td>Field</td>
                <td>
                    One item of sensor data. Contains information about: Node, Field Name, Value, Precision, Unit, Value Type, Status, Timestamp, Localization information, etc.
                    Fields should be unique within the triple (Node ID, Field Name, Timestamp).
                </td>
            </tr>
            <tr>
                <td>Field Name</td>
                <td>Name of a field of sensor data. Examples: Energy, Volume, Flow, Power, etc.</td>
            </tr>
            <tr>
                <td>Field Type</td>
                <td>What type of value the field represents. Examples: Momentary Value, Status Value, Identification Value, Calculated Value, Peak Value, Historical Value, etc.</td>
            </tr>
            <tr>
                <td>Historical Value</td>
                <td>A value stored in memory from a previous timestamp.</td>
            </tr>
            <tr>
                <td>Identification Value</td>
                <td>A value that can be used for identification. (Serial numbers, meter IDs, locations, names, etc.)</td>
            </tr>
            <tr>
                <td>Localization information</td>
                <td>Optional information for a field, allowing the sensor to control how the information should be presented to human viewers.</td>
            </tr>
            <tr>
                <td>Meter</td>
                <td>A device possible containing multiple sensors, used in metering applications. Examples: Electricity meter, Water Meter, Heat Meter, Cooling Meter, etc.</td>
            </tr>
            <tr>
                <td>Momentary Value</td>
                <td>A momentary value represents a value measured at the time of the read-out.</td>
            </tr>
            <tr>
                <td>Node</td>
                <td>
                    Graphs contain nodes and edges between nodes. In Sensor Networks, sensors, actuators, meters, devices, gateways, etc., are often depicted as nodes and links between sensors (friendships)
                    are depicted as edges. In abstract terms, it's easier to talk about a Node, than have to list different types of nodes possible (sensors, actuators, meters, devices, gateways, etc.).
                    Each Node has a Node ID. Nodes belong to a data source, and all nodes have a Node Type. Some nodes have a parent node, and some nodes have child nodes. Nodes with the same 
                    parent nodes a called sibling nodes.
                </td>
            </tr>
            <tr>
                <td>Node ID</td>
                <td>
                    An ID uniquely identifying a node within its corresponding context. If a globally unique ID is desired, an architecture should be used using a universally accepted
                    ID scheme.
                </td>
            </tr>
            <tr>
                <td>Node Type</td>
                <td>Each node has a Node Type. The Node Type defines the funcionality of the node in the system.</td>
            </tr>
            <tr>
                <td>Parameter</td>
                <td>
                    Readable and/or writable property on a node/device. The XEP xep-0000-SN-Concentrators deals with reading and writing parameters
                    on nodes/devices. Fields are not parameters, and parameters are not fields.
                </td>
            </tr>
            <tr>
                <td>Peak Value</td>
                <td>A maximum or minimum value during a given period.</td>
            </tr>
            <tr>
                <td>Precision</td>
                <td>
                    In physics, precision determines the number of digits of precision. In sensor networks however, this definition is not easily applicable. Instead, precision
                    determines, for example, the number of decimals of precision, or power of precision. Example: 123.200 MWh contains 3 decimals of precision. All entities parsing and
                    delivering field information in sensor networks should always retain the number of decimals in a message.
                </td>
            </tr>
            <tr>
                <td>Sensor</td>
                <td>
                    Device measuring at least one digital value (0 or 1) or analog value (value with precision and physical unit). Examples: Temperature sensor, pressure sensor, etc.
                    Sensor values are reported as fields during read-out. Each sensor has a unique Node ID.
                </td>
            </tr>
            <tr>
                <td>SN</td>
                <td>Sensor Network. A network consisting, but not limited to sensors, where transport and use of sensor data is of primary concern. A sensor network may contain actuators, network applications, monitors, services, etc.</td>
            </tr>
            <tr>
                <td>Status Value</td>
                <td>A value displaying status information about something.</td>
            </tr>
            <tr>
                <td>Timestamp</td>
                <td>Timestamp of value, when the value was sampled or recorded.</td>
            </tr>
            <tr>
                <td>Unit</td>
                <td>Physical unit of value. Example: MWh, l/s, etc.</td>
            </tr>
            <tr>
                <td>Value</td>
                <td>A field value.</td>
            </tr>
            <tr>
                <td>Value Status</td>
                <td>Status of field value. Contains important status information for Quality of Service purposes. Examples: Ok, Error, Warning, Time Shifted, Missing, Signed, etc.</td>
            </tr>
            <tr>
                <td>Value Type</td>
                <td>Can be numeric, string, boolean, Date &amp; Time, Time Span or Enumeration.</td>
            </tr>
            <tr>
                <td>SN</td>
                <td>Sensor Network, a sensor network including devices of all types.</td>
            </tr>
            <tr>
                <td>WSN</td>
                <td>Wireless Sensor Network, a sensor network including wireless devices.</td>
            </tr>
            <tr>
                <td>XMPP Client</td>
                <td>Application connected to an XMPP network, having a JID. Note that sensors, as well as applications requesting sensor data can be XMPP clients.</td>
            </tr>
        </table>
    </section1>
    <section1 topic='Use Cases' anchor='usecases'>
        <p>
            To create a complete set of operations supported by all types of concentrators, ranging from PLCs to subsystems to entire systems is very difficult. So, the aim
            of this document is instead to create a very small reduced set of operations, a common denominator, that would allow for basic maintenance and interoperability of 
            concentrators of different makes and models and of these varying ranges.
        </p>
        <section2 topic='Get Capabilities'>
            <p>
                This document lists a sequence of commands. Some are very basic, while others are used for managing massive amounts of devices. When developing a small PLC, it might
                be difficult to motivate the implementation of the more advanced commands. They are simply not necessary for the management of the device. So, clients connecting to 
                the concentrator need a way to learn what operations are available in the concentrator, and as a consequence what operations are not. To do this, the
                <strong>getCapabilities</strong> command is sent, as is shown in the following example.
            </p>
            <example caption='Full capabilities'>
                <![CDATA[
   <iq type='get'
       from='client@clayster.com'
       to='subsystem@clayster.com'
       id='1'>
      <getCapabilities xmlns='urn:xmpp:sn:concentrators'/>
   </iq>
   
   <iq type='result'
       from='subsystem@clayster.com'
       to='client@clayster.com'
       id='1'>
      <getCapabilitiesResponse xmlns='urn:xmpp:sn:concentrators'>
          <value>getCapabilities</value>
          <value>getAllDataSources</value>
          <value>getTopDataSources</value>
          <value>getChildDataSources</value>
          <value>containsNode</value>
          <value>containsNodes</value>
          <value>getNode</value>
          <value>getNodes</value>
          <value>getAllNodes</value>
          <value>getRootNodes</value>
          <value>getChildNodes</value>
          <value>getIndices</value>
          <value>getNodeFromIndex</value>
          <value>getNodesFromIndex</value>
          <value>getAllNodesFromIndex</value>
          <value>getNodeParameters</value>
          <value>getCommonNodeParameters</value>
          <value>getNodeParameterNames</value>
          <value>getNodeParameterValues</value>
          <value>setNodeParameterValues</value>
          <value>getNodeStatus</value>
          <value>getAddableNodeTypes</value>
          <value>getParametersForNewNode</value>
          <value>createNewNode</value>
          <value>destroyNode</value>
          <value>getAncestors</value>
          <value>getNodeCommands</value>
          <value>getCommonNodeCommands</value>
          <value>getCommandParameters</value>
          <value>getCommonCommandParameters</value>
          <value>moveUp</value>
          <value>moveDown</value>
      </getCapabilitiesResponse>
   </iq>]]>
            </example>
            <p>
                A smaller gateway on the other hand, may have skipped the implementation of the batch commands that are used for larger systems:
            </p>
            <example caption='No batch command capabilities'>
                <![CDATA[
   <iq type='get'
       from='client@clayster.com'
       to='gateway@clayster.com'
       id='2'>
      <getCapabilities xmlns='urn:xmpp:sn:concentrators'/>
   </iq>
   
   <iq type='result'
       from='gateway@clayster.com'
       to='client@clayster.com'
       id='2'>
      <getCapabilitiesResponse xmlns='urn:xmpp:sn:concentrators'>
          <value>getCapabilities</value>
          <value>getAllDataSources</value>
          <value>getTopDataSources</value>
          <value>getChildDataSources</value>
          <value>containsNode</value>
          <value>getNode</value>
          <value>getRootNodes</value>
          <value>getChildNodes</value>
          <value>getNodeParameters</value>
          <value>getNodeStatus</value>
          <value>getAddableNodeTypes</value>
          <value>getParametersForNewNode</value>
          <value>createNewNode</value>
          <value>destroyNode</value>
          <value>getAncestors</value>
          <value>getNodeCommands</value>
          <value>getCommandParameters</value>
          <value>moveUp</value>
          <value>moveDown</value>
      </getCapabilitiesResponse>
   </iq>]]>
            </example>
            <p>
                But a small PLC, possibly with a fixed set of nodes, might have support for an even more reduced set of commands:
            </p>
            <example caption='No edit capabilities'>
                <![CDATA[
   <iq type='get'
       from='client@clayster.com'
       to='plc@clayster.com'
       id='3'>
      <getCapabilities xmlns='urn:xmpp:sn:concentrators'/>
   </iq>
   
   <iq type='result'
       from='plc@clayster.com'
       to='client@clayster.com'
       id='3'>
      <getCapabilitiesResponse xmlns='urn:xmpp:sn:concentrators'>
          <value>getCapabilities</value>
          <value>getAllDataSources</value>
          <value>getNode</value>
          <value>getRootNodes</value>
          <value>getChildNodes</value>
          <value>getNodeParameters</value>
          <value>getNodeStatus</value>
          <value>getNodeCommands</value>
          <value>getCommandParameters</value>
      </getCapabilitiesResponse>
   </iq>]]>
            </example>
            <p>
                So, clients who need to interact with different types of concentrators need to be aware of what commands are supported, and limit operations to thos commands.
            </p>
        </section2>
        <section2 topic='Get All Data Sources'>
            <p>
                This command will return a flat list of all available data sources on the concentrator. It is not structured hierarchically.
            </p>
            <example caption='Get All Data Sources'>
                <![CDATA[
   <iq type='get'
       from='client@clayster.com'
       to='concentrator@clayster.com'
       id='4'>
      <getAllDataSources xmlns='urn:xmpp:sn:concentrators' xml:lang='en'/>
   </iq>
   
   <iq type='result'
       from='concentrator@clayster.com'
       to='client@clayster.com'
       id='4'>
      <getAllDataSourcesResponse xmlns='urn:xmpp:sn:concentrators'>
          <dataSource id='Applications' name='Applications' hasChildren='false'/>
          <dataSource id='Certificates' name='Certificates' hasChildren='false'/>
          <dataSource id='Clayster.EventSink.Programmable' name='Programmable Event Log' hasChildren='false'/>
          ...
      </getAllDataSourcesResponse>
   </iq>]]>
            </example>
        </section2>
        <section2 topic='Get Top Data Sources'>
            <p>
                If the client is interested in the hierarchical structure of available data sources, it should request only the root sources, and then ask the client for their
                corresponding child data sources. If the client wants to present the data sources to a user, presenting them in their hierarchical order may be more intuitive.
            </p>
            <example caption='Get Top Data Sources'>
                <![CDATA[
   <iq type='get'
       from='client@clayster.com'
       to='concentrator@clayster.com'
       id='5'>
      <getTopDataSources xmlns='urn:xmpp:sn:concentrators' xml:lang='en'/>
   </iq>
   
   <iq type='result'
       from='concentrator@clayster.com'
       to='client@clayster.com'
       id='5'>
      <getTopDataSourcesResponse xmlns='urn:xmpp:sn:concentrators'>
          <dataSource id='MeteringRoot' name='Metering' hasChildren='true'/>
          <dataSource id='SecurityRoot' name='Security' hasChildren='true'/>
          <dataSource id='SystemRoot' name='System' hasChildren='true'/>
          ...
      </getAllDataSourcesResponse>
   </iq>]]>
            </example>
        </section2>
        <section2 topic='Get Child Data Sources'>
            <p>
                Having the ID of a data source that contains child data sources, you can fetch the child sources as follows:
            </p>
            <example caption='Get Child Data Sources'>
                <![CDATA[
   <iq type='get'
       from='client@clayster.com'
       to='concentrator@clayster.com'
       id='6'>
      <getChildDataSources xmlns='urn:xmpp:sn:concentrators' sourceId='MeteringRoot' xml:lang='en'/>
   </iq>
   
   <iq type='result'
       from='concentrator@clayster.com'
       to='client@clayster.com'
       id='6'>
      <getChildDataSourcesResponse xmlns='urn:xmpp:sn:concentrators'>
          <dataSource id='MeteringFieldImports' name='Field Imports' hasChildren='false'/>
          <dataSource id='MeteringFieldProcessors' name='Field Processors' hasChildren='false'/>
          <dataSource id='MeteringFieldSinks' name='Field Sinks' hasChildren='false'/>
          <dataSource id='MeteringGroups' name='Groups' hasChildren='false'/>
          <dataSource id='MeteringJobs' name='Jobs' hasChildren='false'/>
          <dataSource id='MeteringTopology' name='Topology' hasChildren='false'/>
          <dataSource id='MeteringUnitConversion' name='Unit Conversion' hasChildren='false'/>
      </getChildDataSourcesResponse>
   </iq>]]>
            </example>
        </section2>
        <section2 topic='Contains Node'>
            <p>
                This command permits the client to check the existance of a node on the concetrator.
            </p>
            <example caption='Checking the existance of a node'>
                <![CDATA[
   <iq type='get'
       from='client@clayster.com'
       to='concentrator@clayster.com'
       id='7'>
      <containsNode xmlns='urn:xmpp:sn:concentrators' sourceId='MeteringTopology' nodeId='Node1'/>
   </iq>
   
   <iq type='result'
       from='concentrator@clayster.com'
       to='client@clayster.com'
       id='7'>
      <containsNodeResponse xmlns='urn:xmpp:sn:concentrators'>true</containsNodeResponse>
   </iq>]]>
            </example>
        </section2>
        <section2 topic='Contains Nodes'>
            <p>
                If the client wants to check the existance of multiple nodes on the concentrator, it can use this batch command instead:
            </p>
            <example caption='Checking the existance of a multiple nodes'>
                <![CDATA[
   <iq type='get'
       from='client@clayster.com'
       to='concentrator@clayster.com'
       id='8'>
      <containsNodes xmlns='urn:xmpp:sn:concentrators'>
         <node sourceId='MeteringTopology' nodeId='Node1'/>
         <node sourceId='MeteringTopology' nodeId='Node2'/>
         <node sourceId='MeteringTopology' nodeId='Node3'/>
         <node sourceId='MeteringGroups' nodeId='Group1'/>
      </containsNodes>
   </iq>
   
   <iq type='result'
       from='concentrator@clayster.com'
       to='client@clayster.com'
       id='8'>
      <containsNodesResponse xmlns='urn:xmpp:sn:concentrators'>
	     <value>true</value>
	     <value>true</value>
	     <value>false</value>
	     <value>true</value>
      </containsNodeResponse>
   </iq>]]>
            </example>
			<p>
				The array returned will have one item for each item in the request, in the same order.
			</p>
        </section2>
        <section2 topic='Get Node'>
			<p>
				This command returns basic information about a node in the concentrator.
			</p>
			<example caption='Get Node'>
				<![CDATA[
   <iq type='get'
       from='client@clayster.com'
       to='concentrator@clayster.com'
       id='9'>
      <getNode xmlns='urn:xmpp:sn:concentrators' sourceId='MeteringTopology' nodeId='Node1'/>
   </iq>
   
   <iq type='result'
       from='concentrator@clayster.com'
       to='client@clayster.com'
       id='9'>
      <getNodeResponse xmlns='urn:xmpp:sn:concentrators' 
	                   id='Node1'
					   cacheType='Node'
					   state='Warning'
					   hasChildren='false'
					   isReadable='true'
					   isConfigurable='true'
					   hasCommands='true'/>
   </iq>]]>
			</example>
			<p>
				For more information, see <link url='#nodeinfo'>Node Information</link>.
			</p>
        </section2>
        <section2 topic='Get Nodes'>
			<p>
				This commands lets the client get information from multiple nodes at once.
				<!-- TODO: GetNodeWithParameters -->
				<!-- TODO: GetNodesWithParameters -->
			</p>
        </section2>
        <section2 topic='Get All Nodes'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get All Nodes derived from'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get indices of Data Source'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Node from index'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Nodes from index'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get All Nodes from index'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Root Nodes'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Child Nodes'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Node Parameters'>
            <!-- TODO -->
        </section2>
        <section2 topic='Set Node Parameters'>
            <!-- TODO -->
        </section2>
        <section2 topic='Set Node Parameters Failure'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Common Node Parameters'>
            <!-- TODO -->
        </section2>
        <section2 topic='Set Common Node Parameters'>
            <!-- TODO -->
        </section2>
        <section2 topic='Set Common Node Parameters Failure'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Node Parameter Names'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Node Parameter Values'>
            <!-- TODO -->
        </section2>
        <section2 topic='Set Node Parameter Values'>
            <!-- TODO -->
        </section2>
        <section2 topic='Set Node Parameter Values Failure'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Node Status'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Addable Node Types'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Parameters for New Node'>
            <!-- TODO -->
        </section2>
        <section2 topic='Create New Node'>
            <!-- TODO -->
        </section2>
        <section2 topic='Create New Node Failure'>
            <!-- TODO -->
        </section2>
        <section2 topic='Destroy Node'>
            <!-- TODO -->
        </section2>
        <section2 topic='Destroy Node Failure'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Node Ancestors'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Node Commands'>
            <!-- TODO -->
        </section2>
        <section2 topic='Execute Simple Node Command'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Common Commands for Nodes'>
            <!-- TODO -->
        </section2>
        <section2 topic='Execute Simple Command on multiple Nodes'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Node Command Parameters'>
            <!-- TODO -->
        </section2>
        <section2 topic='Execute Parametrized Node Command'>
            <!-- TODO -->
        </section2>
        <section2 topic='Get Common Command Parameters from command on multiple nodes'>
            <!-- TODO -->
        </section2>
        <section2 topic='Execute Parametrized Command on multiple Nodes'>
            <!-- TODO -->
        </section2>
        <section2 topic='Move Node Up'>
            <!-- TODO -->
        </section2>
        <section2 topic='Move Node Down'>
            <!-- TODO -->
        </section2>
    </section1>
    <section1 topic='Implementation Notes' anchor='impl'>
		<section2 topic='Node Information' anchor='nodeinfo'>
			<p>
				Several commands return basic node information. The following table lists possible fields with corresponding descriptions.
			</p>
			<table caption='Basic Node Information'>
				<tr>
					<th>Attribute</th>
					<th>Use</th>
					<th>Default</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>id</td>
					<td>required</td>
					<td>&nbsp;</td>
					<td>The ID of the node in the data source.</td>
				</tr>
				<tr>
					<td>displayName</td>
					<td>optional</td>
					<td>&nbsp;</td>
					<td>If provided, a string presentable to users. If localization is supported and a correct language attribute was provided, this string will be localized.</td>
				</tr>
				<tr>
					<td>localId</td>
					<td>optional</td>
					<td>&nbsp;</td>
					<td>If provided, an ID for the node, but unique locally between siblings.</td>
				</tr>
				<tr>
					<td>logId</td>
					<td>optional</td>
					<td>&nbsp;</td>
					<td>If provided, an ID for the node, as it would appear or be used in system logs.</td>
				</tr>
				<tr>
					<td>cacheType</td>
					<td>required</td>
					<td>&nbsp;</td>
					<td>Used to uniquelly identify the node. If concentrators do not use this parameter, they can set this string to the empty string.</td>
				</tr>
				<tr>
					<td>state</td>
					<td>required</td>
					<td>&nbsp;</td>
					<td>Current overall state of the node.</td>
				</tr>
				<tr>
					<td>hasChildren</td>
					<td>required</td>
					<td>&nbsp;</td>
					<td>If the node has children or not.</td>
				</tr>
				<tr>
					<td>isReadable</td>
					<td>optional</td>
					<td>false</td>
					<td>If the node can be read. (*)</td>
				</tr>
				<tr>
					<td>isConfigurable</td>
					<td>optional</td>
					<td>false</td>
					<td>If the node can be configured. (**)</td>
				</tr>
				<tr>
					<td>hasCommands</td>
					<td>optional</td>
					<td>false</td>
					<td>If the node has registered commands or not.</td>
				</tr>
			</table>
			<p>
				(*) See <link url='xep-0000-SN-SensorData.html'>xep-0000-SN-SensorData</link> for more information about how to read nodes.
			</p>
			<p>
				(**) See <link url='xep-0000-SN-Control.html'>xep-0000-SN-Control</link> for more information about how to configure nodes.
			</p>
		</section2>
        <!-- TODO: Requirement to implement the Sensor Data XEP (data source: Topology) -->
    </section1>
    <section1 topic='Internationalization Considerations' anchor='i18n'>
        <p>
            Loalization of content can be performed if clients provide <strong>xml:lang</strong> attributes in commands made to the concentrator. If omitted, the
            <strong>default language</strong> will be used in responses. If provided, but the concentrator does not support localization, or the requested language,
            the <strong>default language</strong> will also be used.
        </p>
    </section1>
    <section1 topic='Security Considerations' anchor='security'>
        <section2 anchor='Access rights'>
            <p>
                This document publishes a lot of commands with which to interact with a concentrator. If security and access rights is an issue, it might not be sufficient
                to allow all friends access to the system. There are many ways in which to restrict access to the contents of the concentrator. Following are some examples:
            </p>
            <ul>
                <li>
                    The concentrator can restrict friendships to trusted friends, and then assign access rights internally to the approved contacts.
                </li>
                <li>
                    The concentrator can use a provisioning server (see <link url='xep-0000-SN-Provisioning.html'>xep-0000-SN-Provisioning.html</link>) to delegate trust
                    to a third party responsible for controlling who can get access to the concentrator (<strong>isFriend</strong> or <strong>canAccess</strong> commands), 
                    and what items can be viewed (<strong>hasPrivilege</strong> or <strong>downloadPrivileges</strong> commands).
                </li>
            </ul>
        </section2>
        <section2 topic='Restricting access to node commands per contact'>
            <!-- TODO -->
        </section2>
        <section2 topic='Restricting access to node commands per contact'>
            <!-- TODO -->
        </section2>
    </section1>
    <section1 topic='IANA Considerations' anchor='iana'>
        <p>REQUIRED.</p>
    </section1>
    <section1 topic='XMPP Registrar Considerations' anchor='registrar'>
        <p>REQUIRED.</p>
    </section1>
    <section1 topic='XML Schema' anchor='schema'>
        <code>
            <![CDATA[
<?xml version='1.0' encoding='UTF-8'?>
<xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:xmpp:sn:concentrators'
    xmlns='urn:xmpp:sn:concentrators'
    xmlns:sn='urn:xmpp:sn'
    xmlns:xd="jabber:x:data"
    xmlns:xdv="http://jabber.org/protocol/xdata-validate"
    xmlns:xdl="http://jabber.org/protocol/xdata-layout"
    elementFormDefault='qualified'>
 
    <xs:import namespace='urn:xmpp:sn'/>
    <xs:import namespace='jabber:x:data'/>
    <xs:import namespace='http://jabber.org/protocol/xdata-validate'/>
    <xs:import namespace='http://jabber.org/protocol/xdata-layout'/>
 
    <xs:element name='getCapabilities' type='EmptyElement'/>
    <xs:element name='getCapabilitiesResponse' type='StringArray'/>
 
    <xs:element name='getAllDataSources' type='EmptyElement'/>
    <xs:element name='getAllDataSourcesResponse' type='DataSourceArray'/>
 
    <xs:element name='getTopDataSources' type='EmptyElement'/>
    <xs:element name='getTopDataSourcesResponse' type='DataSourceArray'/>
 
    <xs:element name='getChildDataSources' type='SourceReference'/>
    <xs:element name='getChildDataSourcesResponse' type='DataSourceArray'/>
 
    <xs:complexType name='EmptyElement'>
    </xs:complexType>
 
    <xs:complexType name='SourceReference'>
        <xs:attributeGroup ref='sourceReference'/>
    </xs:complexType>
 
    <xs:attributeGroup name='sourceReference'>
        <xs:attribute name='sourceId' type='xs:string' use='required'/>
    </xs:attributeGroup>
 
    <xs:complexType name='DataSource'>
        <xs:attribute name='id' type='xs:string' use='required'/>
        <xs:attribute name='name' type='xs:string' use='required'/>
        <xs:attribute name='hasChildren' type='xs:boolean' use='optional' default='false'/>
    </xs:complexType>
 
    <xs:complexType name='DataSourceArray'>
        <xs:sequence minOccurs='0' maxOccurs='unbounded'>
            <xs:element name='dataSource' type='DataSource'/>
        </xs:sequence>
    </xs:complexType>
 
    <xs:element name='containsNode' type='NodeReference'/>
    <xs:element name='containsNodeResponse' type='xs:boolean'/>
 
    <xs:element name='containsNodes' type='NodeReferences'/>
    <xs:element name='containsNodesResponse' type='BooleanArray'/>
 
    <xs:complexType name='NodeReference'>
        <xs:attributeGroup ref='nodeReference'/>
    </xs:complexType>
 
    <xs:complexType name='NodeReferences'>
        <xs:sequence minOccurs='0' maxOccurs='unbounded'>
            <xs:element name='node' type='NodeReference'/>
        </xs:sequence>
    </xs:complexType>
 
    <xs:attributeGroup name='nodeReference'>
        <xs:attributeGroup ref='sourceReference'/>
        <xs:attribute name='nodeId' type='xs:string' use='required'/>
        <xs:attribute name='cacheType' type='xs:string' use='optional'/>
    </xs:attributeGroup>
 
    <xs:element name='getNode' type='NodeReference'/>
    <xs:element name='getNodeResponse' type='NodeInformation'/>
 
    <xs:element name='getNodes' type='NodeReferences'/>
    <xs:element name='getNodesResponse' type='NodeInformationArray'/>
 
    <xs:element name='getAllNodes' type='GetAllNodes'/>
    <xs:element name='getAllNodesResponse' type='NodeInformationArray'/>
 
    <xs:element name='getRootNodes' type='SourceReference'/>
    <xs:element name='getRootNodesResponse' type='NodeInformationArray'/>
 
    <xs:element name='getChildNodes' type='GetChildNodes'/>
    <xs:element name='getChildNodesResponse' type='NodeInformationArray'/>
 
    <xs:complexType name='GetAllNodes'>
        <xs:complexContent>
            <xs:extension base='SourceReference'>
                <xs:sequence minOccurs='0' maxOccurs='unbounded'>
                    <xs:element name='onlyIfDerivedFrom' type='xs:string'/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='GetChildNodes'>
        <xs:complexContent>
            <xs:extension base='NodeReference'>
                <xs:sequence minOccurs='0' maxOccurs='unbounded'>
                    <xs:element name='sortOrder' type='SortOrder'/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='SortOrder'>
        <xs:attribute name='parameterName' type='xs:string' use='required'/>
        <xs:attribute name='ascending' type='xs:boolean' use='optional' default='true'/>
    </xs:complexType>
 
    <xs:complexType name='NodeInformation'>
        <xs:attribute name='id' type='xs:string' use='required'/>
        <xs:attribute name='displayName' type='xs:string' use='optional'/>
        <xs:attribute name='localId' type='xs:string' use='optional'/>
        <xs:attribute name='logId' type='xs:string' use='optional'/>
        <xs:attribute name='cacheType' type='xs:string' use='required'/>
        <xs:attribute name='state' type='NodeState' use='required'/>
        <xs:attribute name='hasChildren' type='xs:boolean' use='required'/>
        <xs:attribute name='isReadable' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='isConfigurable' type='xs:boolean' use='optional' default='false'/>
        <xs:attribute name='hasCommands' type='xs:boolean' use='optional' default='false'/>
    </xs:complexType>
 
    <xs:complexType name='NodeInformationArray'>
        <xs:sequence minOccurs='0' maxOccurs='unbounded'>
            <xs:element name='node' type='NodeInformation'/>
        </xs:sequence>
    </xs:complexType>
 
    <xs:simpleType name='NodeState'>
        <xs:restriction base='xs:string'>
            <xs:enumeration value='None'/>
            <xs:enumeration value='Information'/>
            <xs:enumeration value='WarningSigned'/>
            <xs:enumeration value='WarningUnsigned'/>
            <xs:enumeration value='ErrorSigned'/>
            <xs:enumeration value='ErrorUnsigned'/>
        </xs:restriction>
    </xs:simpleType>
 
    <xs:element name='getIndices' type='SourceReference'/>
    <xs:element name='getIndicesResponse' type='StringArray'/>
 
    <xs:complexType name='StringArray'>
        <xs:sequence minOccurs='0' maxOccurs='unbounded'>
            <xs:element name='value' type='xs:string'/>
        </xs:sequence>
    </xs:complexType>
 
    <xs:complexType name='BooleanArray'>
        <xs:sequence minOccurs='0' maxOccurs='unbounded'>
            <xs:element name='value' type='xs:boolean'/>
        </xs:sequence>
    </xs:complexType>
 
    <xs:element name='getNodeFromIndex' type='IndexReference'/>
    <xs:element name='getNodeFromIndexResponse' type='NodeInformation'/>
 
    <xs:element name='getNodesFromIndex' type='IndexReferences'/>
    <xs:element name='getNodesFromIndexResponse' type='NodeInformationArray'/>
 
    <xs:complexType name='IndexReference'>
        <xs:attributeGroup ref='indexReference'/>
    </xs:complexType>
 
    <xs:complexType name='IndexReferences'>
        <xs:sequence minOccurs='0' maxOccurs='unbounded'>
            <xs:element name='indexRef' type='IndexReference'/>
        </xs:sequence>
    </xs:complexType>
 
    <xs:attributeGroup name='indexReference'>
        <xs:attributeGroup ref='sourceReference'/>
        <xs:attribute name='index' type='xs:string' use='required'/>
        <xs:attribute name='indexValue' type='xs:string' use='required'/>
    </xs:attributeGroup>
 
    <xs:element name='getAllNodesFromIndex' type='IndexReference'/>
    <xs:element name='getAllNodesFromIndexResponse' type='NodeInformationArray'/>
 
    <xs:element name='getNodeParameters' type='NodeReference'/>
    <xs:element name='getNodeParametersResponse' type='ParameterForm'/>
 
    <xs:element name='getCommonNodeParameters' type='NodeReferences'/>
    <xs:element name='getCommonNodeParametersResponse' type='ParameterForm'/>
 
    <xs:complexType name='ParameterForm'>
        <xs:sequence>
            <xs:any minOccurs="1" maxOccurs="1" namespace="jabber:x:data" id="x"/>
        </xs:sequence>
    </xs:complexType>
 
    <xs:element name='getNodeParameterNames' type='NodeReference'/>
    <xs:element name='getNodeParameterNamesResponse' type='StringArray'/>
 
    <xs:element name='getNodeParameterValues' type='GetNodeParameterValues'/>
    <xs:element name='getNodeParameterValuesResponse' type='StringArray'/>
 
    <xs:complexType name='GetNodeParameterValues'>
        <xs:complexContent>
            <xs:extension base='NodeReference'>
                <xs:sequence minOccurs='0' maxOccurs='unbounded'>
                    <xs:element name='parameterName' type='xs:string'/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:element name='setNodeParameterValues' type='SetNodeParameterValues'/>
    <xs:element name='setNodeParameterValuesResponse' type='StringArray'/>
 
    <xs:complexType name='SetNodeParameterValues'>
        <xs:complexContent>
            <xs:extension base='NodeReference'>
                <xs:sequence minOccurs='0' maxOccurs='unbounded'>
                    <xs:element name='parameter' type='Parameter'/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:complexType name='Parameter'>
        <xs:attribute name='name' type='xs:string' use='required'/>
        <xs:attribute name='value' type='xs:string' use='required'/>
    </xs:complexType>
 
    <xs:element name='getNodeStatus' type='NodeReference'/>
    <xs:element name='getNodeStatusResponse' type='MessageArray'/>
 
    <xs:complexType name='Message'>
        <xs:simpleContent>
            <xs:extension base='xs:string'>
                <xs:attribute name='timestamp' type='xs:dateTime' use='required'/>
                <xs:attribute name='type' type='MessageType' use='required'/>
                <xs:attribute name='id' type='xs:string' use='optional'/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
 
    <xs:complexType name='MessageArray'>
        <xs:sequence minOccurs='0' maxOccurs='unbounded'>
            <xs:element name='message' type='Message'/>
        </xs:sequence>
    </xs:complexType>
 
    <xs:simpleType name='MessageType'>
        <xs:restriction base='xs:string'>
            <xs:enumeration value='Error'/>
            <xs:enumeration value='Warning'/>
            <xs:enumeration value='Information'/>
        </xs:restriction>
    </xs:simpleType>
 
    <xs:element name='getAddableNodeTypes' type='NodeReference'/>
    <xs:element name='getAddableNodeTypesResponse' type='StringArray'/>
 
    <xs:element name='getParametersForNewNode' type='NodeTypeReference'/>
    <xs:element name='getParametersForNewNodeResponse' type='ParameterForm'/>
 
    <xs:complexType name='NodeTypeReference'>
        <xs:complexContent>
            <xs:extension base='NodeReference'>
                <xs:attribute name='type' type='xs:string' use='required'/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:element name='createNewNode' type='NodeTypeReference'/>
    <xs:element name='createNewNodeResponse' type='NodeInformation'/>
 
    <xs:element name='destroyNode' type='NodeReference'/>
    <xs:element name='destroyNodeResponse' type='EmptyElement'/>
 
    <xs:element name='getAncestors' type='NodeReference'/>
    <xs:element name='getAncestorsResponse' type='NodeInformationArray'/>
 
    <xs:element name='getNodeCommands' type='NodeReference'/>
    <xs:element name='getNodeCommandsResponse' type='CommandArray'/>
 
    <xs:element name='getCommonNodeCommands' type='NodeReferences'/>
    <xs:element name='getCommonNodeCommandsResponse' type='CommandArray'/>
 
    <xs:complexType name='Command'>
        <xs:attribute name='id' type='xs:string' use='required'/>
        <xs:attribute name='name' type='xs:string' use='required'/>
        <xs:attribute name='type' type='CommandType' use='required'/>
        <xs:attribute name='sortCategory' type='xs:string' use='optional'/>
        <xs:attribute name='sortKey' type='xs:string' use='optional'/>
        <xs:attribute name='confirmationString' type='xs:string' use='optional'/>
        <xs:attribute name='failureString' type='xs:string' use='optional'/>
        <xs:attribute name='successString' type='xs:string' use='optional'/>
    </xs:complexType>
 
    <xs:complexType name='CommandArray'>
        <xs:sequence minOccurs='0' maxOccurs='unbounded'>
            <xs:element name='message' type='Command'/>
        </xs:sequence>
    </xs:complexType>
 
    <xs:simpleType name='CommandType'>
        <xs:restriction base='xs:string'>
            <xs:enumeration value='Simple'/>
            <xs:enumeration value='Parametrized'/>
        </xs:restriction>
    </xs:simpleType>
 
    <xs:complexType name='NodeCommandReference'>
        <xs:complexContent>
            <xs:extension base='NodeReference'>
                <xs:attribute name='command' type='xs:string' use='required'/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
 
    <xs:element name='getCommandParameters' type='NodeCommandReference'/>
    <xs:element name='getCommandParametersResponse' type='ParameterForm'/>
 
    <xs:element name='getCommonCommandParameters'>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base='NodeReferences'>
                    <xs:attribute name='command' type='xs:string' use='required'/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name='getCommonCommandParametersResponse' type='ParameterForm'/>
 
    <xs:element name='moveUp' type='NodeReference'/>
    <xs:element name='moveUpResponse' type='EmptyElement'/>
 
    <xs:element name='moveDown' type='NodeReference'/>
    <xs:element name='moveDownResponse' type='EmptyElement'/>
 
</xs:schema>]]>
        </code>
    </section1>
</xep>